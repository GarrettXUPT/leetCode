# 线程同步

可通过临界区、互斥区、事件、信号量来实现

下为该四种方式的区别：

## 1、临界区(Critical Section)

​	通过对多线程的串行化来访问公共资源或者是一段代码，适合控制数据访问。

​	在该时刻只允许一个线程对公共资源进行访问，如果有多个线程试图访问公共资源，那么在一个线程进入以后其他试图访问该资源的线程将被挂起，知道进入临界区的线程离开临界区，临界区被释放后，其他线程才可以抢占

## 2、互斥量(Mutex)

​	采用互斥对象机制。

​	只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一个应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量要比临界区更加复杂。因为使用互斥不仅仅能够哎同一个应用程序不同线程之间实现资源的安全共享，而且可以在不同应用程序之间实现对资源的安全共享

## 3、信号量

​	它允许多个线程在同一个时刻访问同一个资源，但是需要限制值同一时刻访问次资源的最大线程数目，信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用公共资源。这与操作系统的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是限制同一时刻访问资源的最大线程数目。

​	PV操作及信号量的概念是一个荷兰科学家Dijkatra提出。信号量S是个一整数，S大于等于零时代表可供并发线程使用的资源实体数，S小于零则代表正在等待使用共享资源的进程数

​	P操作申请资源：

​	1、S减一

​	2、若S减一后仍然大于等于零，则进程继续执行

​	3、若S减一后小于零，则该线程被阻塞后进入与该信号相对的队列中，然后转入线程调度

​	V操作释放资源：

​	1、S加一

​	2、若S加一结果大于零，那么该线程继续运行

​	3、若相加结果小于等于0，则从该信号的等待队列中唤醒一个等待进程，然后再返回原线程继续执行或者转入调度

​	关于PV操作：

​	1、S大于0时候，为什么不对线程进行唤醒？

​			因为在S大于0的时候，没有线程阻塞在该资源商，所以不需要唤醒

​	2、S小于0时，应该没有临界资源可以使用，为什么要唤醒线程？

​			V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S<0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。

​	3、如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S<0，也还是执行不了，这是怎么回事呢？

​			当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。

​	4、S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？

​			当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。

## 4、事件(Event)

​	通过通知的操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级上做比较

## 5、总结

​	1、互斥量与临界区十分相似，但是互斥量可以命名，也就意味着他可以跨越进程使用。所以创建互斥量需要消耗的资源是比较多的，所以只是为了在进程内部实用的话，还是要使用临界区，这样会带来速度上的优势，并且可以减少资源的占用量。因为互斥量是跨进程的，若是一旦被创建，就可以使用名字打开它

​	2、互斥量、信号量、事件都可以被跨进程使用来进行同步数据操作，二其他的对象与数据同步操作无关，但对于进程和线程来讲，若进程和线程在运行状态则为无信号状态，在退出后就是由信号状态。所以可以使用WaitForSingleObject来等待进程和线程的退出

​	3、通过互斥量可以指定资源被独占的方式使用，但若是有一种情况通过互斥量就无法进行处理。如：`一个用户购买了三个并发访问许可的数据库系统`，可以根据用户购买的访问许可数量来决定有多少个线程/进程能够同时进行数据库操作，此时就不可以使用互斥量来完成了，此时应该使用信号量对象来进行资源计数。



# 进程通信

​	进程间通信就是指不同进程之间传播或者交换信息，那么不同进程之间存在着设么双方都可以访问的介质呢？

​	进程的用户空间是相互独立的，一般而言是不可以相互访问的，维一的例外是共享内存区。但是，系统空间却是“公共场所”，所以显然内核可以提供这样的条件。除此之外就是双方都可以访问的外设。在这个意义上，两个进程当然可以通过磁盘上的普通文件交换信息，或者通过“注册表”或者数据库中的某些表项和记录交换信息。但是这些“进程间通信”效率低下，而人们对进程间的通信的要求是具有一定的实时性。

​	进程间通信主要包括：管道，系统IPC(包括消息队列，信号量，共享存储)，Socket

​	管道分为有名管道与无名管道。无名管道只能用于亲属进程之间的通信，而有名管道则可以用于无亲属关系的进程之间

​	消息队列用于同一台机器上的进程间通信，与管道相似

​	共享内存通常由一个进程创建，其他进程对该块内存进行读写。得到共享内存有两种方式：映射/dev/mem设备和内存映象文件。前一种方式不会带来额外的系统开销，但在现实中并不常用，因为它控制存取的是实际的物理内存。

​	本质上，信号量是一个计数器，它用来记录对某个资源(共享内存)的存取状况。一般来说为了获取共享资源，进程需要执行下列操作：

​	1、测试控制该资源的信号量

​	2、若此信号两位整，则允许使用该资源，进程将信号量减一

​	3、若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量的值大于0，进程被唤醒，转入1

​	4、当进程不再使用一个信号量控制的资源的时候，信号量值加一，若存在进程正在睡眠等待该资源，就唤醒该进程

​	套接字通信并不是Linux系统专有的，在所有提供了TCP/IP协议栈的操作系统中都提供了socket，而这样的操作系统，对于套接字的编程时一样的

​	进程间通信(IPC)方法主要有以下几种：管道/FIFO/共享内存/消息队列/信号

## 管道

​	管道中存在命名管道和非命名管道的区别。

​	非命名管道(匿名管道)只能用于父子进程之间的通信。

​	命名管道可用于非父子进程之间的通信，命名管道就是FIFO，先进先出的通信方式

## 消息队列

​	消息队列是两个进程之间的通信。首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，若是一个进程向某个消息队列写入数据以后，另一个进程没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列的数据也没有消失，也就是说，下次再从这个消息队列中读取数据的时候，还是上次写入的数据

## 信号量

​	此处的信号量与Windows下的信号量是一样的

## 共享内存

​	类似于Windows下的DLL中的共享变量，但是在Linux中不存在DLL这种东西，只需要先创建一个共享内存区，其他进程按照一定的步骤就可以访问到该共享内存区中的数据，可读可写

## 以上几种方式的比较

​	1、管道：速度慢，容量有限，只有父子通信的时候才可以使用

​	2、FIDO：任何进程间都可以通信，但速度较快

​	3、消息队列：容量受到系统限制，但是要注意在第一次读的时候，要考虑上次还没有读完数据的问题

​	4、信号量：不可以传递复杂消息，只能用于同步

​	5、共享内存区：能够很容易的控制容量且速度快，但是要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，内存区同样可以用作线程间通信，但是没有必要，因为线程本来就属于同一块内存

# 线程同步与进程通信之间的比较

同步主要是使用临界区、互斥、信号量、事件

通信主要是使用管道、内存共享、消息队列、信号量和socket

共同之处是信号量和事件